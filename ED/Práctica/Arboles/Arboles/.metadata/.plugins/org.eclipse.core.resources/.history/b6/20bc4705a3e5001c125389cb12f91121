/**
 * 
 */
package bst;

/**
 * @author UO285176
 *
 */
public class BSTree<T extends Comparable<T>> {
	private BSTNode<T> raiz;// nodo raíz del árbol BST

	/*
	 * Constructor
	 */
	public BSTree() {
		this.raiz = null;
	}

	/*
	 * Si la raíz o la clave es null devuelve null Si no lo son invoca a un método
	 * recursivo que busca la clave por la derecha o por la izquierda, dependiendo
	 * si la clave es mayor o menor que el nodo a partir del cual se busca. Devuelve
	 * el nodo completo o null si no lo encuentra.
	 */
	public BSTNode<T> searchNode(T clave) {
		if (this.raiz == null || clave == null)
			return null;
		else
			return searchNodeRecursivo(this.raiz, clave);
	}

	private BSTNode<T> searchNodeRecursivo(BSTNode<T> nodoraiz, T clave) {
		if (nodoraiz == null)
			return null;
		else if (nodoraiz.getInfo().compareTo(clave) == 0)// la raiz contiene la misma informacion que la clave
			return nodoraiz;
		else if (nodoraiz.getInfo().compareTo(clave) > 0)// si la clave es menor que el nodo, busca por la izquierda
			return searchNodeRecursivo(nodoraiz.getLeft(), clave);
		else if (nodoraiz.getInfo().compareTo(clave) < 0)// si el nodo es menor que la clave, busca por la derecha
			return searchNodeRecursivo(nodoraiz.getRight(), clave);
		else// si no lo encuentra devuelve null
			return null;
	}

	/*
	 * Si la clave es null devuelve -2 Si la clave ya existe devuelve -1 Si la raíz
	 * es null, se crea un nodo con la clave que asignamos a la raiz y devuelve 0
	 * 
	 * Sino se invoca a un método recursivo con el nodo a partir del cual queremos
	 * insertar y la clave a insertar. El método busca un hueco por la derecha o por
	 * la izquierda, dependiendo de si la clave es mayor o menor que el nodo raiz.
	 * Cuando lo encuentra, crea un nuevo nodo con la clave y lo asigna por la
	 * derecha o por la izquierda y devuelve 0.
	 */
	public int addNode(T clave) {
		if (clave == null)
			return -2;
		else if (searchNode(clave) != null)
			return -1;
		else if (this.raiz == null) {
			this.raiz = new BSTNode<T>(clave);
			return 0;
		} else {
			return addNodeRecursivo(this.raiz, clave);
		}

	}

	private int addNodeRecursivo(BSTNode<T> nodoraiz, T clave) {
		if (nodoraiz.getInfo().compareTo(clave) > 0) {// si la raiz es mayor que la clave, busca por la izquierda
			if (nodoraiz.getLeft() != null)
				return addNodeRecursivo(nodoraiz.getLeft(), clave);
			else {
				nodoraiz.setLeft(new BSTNode<T>(clave));
				return 0;
			}
		} else if (nodoraiz.getInfo().compareTo(clave) < 0) {// si la raiz es menor que la clave, busca por la derecha
			if(nodoraiz.getRight() != null)
				return addNodeRecursivo(nodoraiz.getRight(), clave);
			else {
				nodoraiz.setRight(new BSTNode<T>(clave));
				return 0;
			}
		}
		return -1;//si ya existiese la clave, devolvería -1
	}

}
